# Занятие 2: Классы, наследование, внутренние классы

## Задача 1

В этом задании требуется реализовать класс для представления целочисленных JSON-свойств с изменяемым значением
и фиксированным именем. Сделайте так, чтобы код в функции `RunTest` компилировался и проходил тесты, печатая при запуске
следующее:

```
age: 21
age: 21
age: 22
age: 23
age: 24
System.ArgumentException: Property name is immutable
System.FormatException: For input string: "?"
System.ArgumentException: Incorrect JSON property format: 'age = 10'
JSON value of 'age' has been set 4 time(s)
count: 0
JSON value of 'count' has been set 1 time(s)
Class 'JsonIntProperty' instance has been created 2 time(s)
```

При выполнении задания вам потребуются изменяемые и неизменяемые свойства, геттеры и сеттеры, статичные свойства и другие элементы объявления классов в C#.

## Задача 2

Код в заготовке содержит не самую удачную реализацию наследования классов животных: её проблема в том, 
что переопределяемая в наследниках функция `Talk` многократно дублирует соответствующую функциональность.
Перепишите код классов так, чтобы функция `Talk` в наследниках не переопределялась, но код и вывод функции
`RunTest` остались прежними.

## Задача 3

Иногда классы в иерархии наследования настолько различны, что при их обработке приходится явно
ориентироваться на конкретный класс имеющегося объекта с помощью операций `is` и `as`. В заготовке задания
имеется одна из таких иерархий. Раскомментируйте код функции `RunTest` и реализуйте 
функции `PrintMessageFrom` и `FindDogs` так, чтобы проходили тесты, а при работе основной программы 
в терминале печаталось следующее:

```
Все сообщения:
Ты меня не видишь
Гав!
Привет, я человек!
Гав!

Сообщения только от собак:
Гав!
Гав!
```

## Начисление баллов за занятие

Задача 1: 2 балла

Задача 2: 1 балл

Задача 3: 2 балла

# Занятие 3: Интерфейсы и обобщенные типы

## Задание 1

1. Определите интерфейс `Computer` с единственной функцией `CalculateAnswer` без параметров, возвращающей 
значение типа `int`. 
2. Определите класс десктопного компьютера `Desktop`, объекты которого инициализируются значением типа `int`. Реализуйте в этом
классе интерфейс `Computer` так, чтобы функция из него возвращала заданное значение.
3. Определите класс `SummingCloud`, инициализируемый количеством узлов, входящих в облако, 
и хранящий все узлы как список объектов класса, реализующего интерфейс `Computer` (`List<Computer>`).
Отдельные узлы облака должны создаваться как десктопные компьютеры, инициализированные числами
от 1 до `n`, где `n` — их количество. 
Реализуйте в этом классе интерфейс `Computer` так, чтобы функция из него возвращала сумму значений,
вычисленных отдельными узлами.

## Задание 2

Код в заготовке содержит не самую удачную реализацию наследования классов животных: её проблема в том, 
что переопределяемая в наследниках функция `Talk` дублирует функциональность,
троекратно печатая соответствующую виду животного [ономатопею](https://ru.wikipedia.org/wiki/Ономатопея). 
Другая проблема состоит в том, что функция `Talk` вполне могла бы использоваться и не животными 
(например, четырёхкратно урчащими роботами-пылесосами).

1. Определите интерфейс `ITalkable`, содержащий строковое свойство для чтения `Sound` и функцию `Talk`.
2. Реализуйте интерфейс `ITalkable` в классе `AbstractAnimal`, задав определение функции `Talk` (троекратная печать
ономатопеи `Sound`) и оставив без реализации свойство `Sound`.
3. Реализуйте свойство `Sound` в наследниках класса `AbstractAnimal` соответственно виду животного.
4. Определите класс `RobotVacuum`, реализующий интерфейс `Talkable` выводом на консоль строки `"ур-ур-ур-ур"`
   (`Sound` => `"ур"`).

## Задание 3

Классы, с которыми приходится работать в программе, могут приходить из разных библиотек и не иметь
практически ничего общего. Например, в заготовке определены три не связанных между собой класса,
имеющих по одному строковому свойству. В таких случаях можно, пользуясь вспомогательными классами и интерфейсами,
создавать *адаптеры*, позволяющие работать с такими классами однообразно. 

1. Определите интерфейс `Creature` со строковым свойством `Message`.
2. Для каждого из классов заготовки определите класс `*Adapter` (`HumanAdapter` и т.д.) следующим образом:
    - его конструктор должен принимать на вход экземпляр исходного класса;
    - этот класс должен реализовывать интерфейс `Creature`, беря текст сообщения из 
      экземпляра исходного класса.
3. Заполните список `creatures` в функции `Main` экземплярами адаптеров и убедитесь,
что печать всех сообщений теперь выполняется однообразно (по сравнению с реализацией из предыдущего занятия).
4. Подход с адаптером можно применить и к другим классам, например, к классу `RobotVacuum`
из предыдущего задания. Можно считать, что сообщением в этом случае будет значение свойства `Sound`.
Обратите внимание, что мы можем начать работу с этим классом, никак не модифицируя его определение, только поменяв область видимости (при необходимости).
Достаточно лишь определить для него класс-адаптер, причём именно в модуле этого задания. 
Сделайте это и добавьте робот-пылесос к списку `creatures` в функции `Main`.

## Задание 4

Это задание посвящено обобщённым типам. Оно состоит из трёх частей. Решения для второй и третьей частей не должны 
никаким образом затрагивать код, написанный для предыдущих частей.

### Часть 1: класс Box

Определите открытый класс `Box` так, чтобы исполнение функции `Part1` приводило к следующему выводу:
```
=== Часть 1: класс Box ===
Box b: 6
ERROR: Box is not empty
ERROR: Box is empty
ERROR: Box is empty
Box b: 0
Box b2: hello
String's length is 5
String's length is 3
```

*Важно*: не определяйте в интерфейсе класса ничего лишнего.

### Часть 2: функция convert

Определите функцию `Convert` так, чтобы исполнение функции `Part2` приводило к следующему выводу:
```
=== Часть 2: функция convert ===
Box stringBox: 42!
ERROR: Box is empty
Box intBox2: 3
Box intBox3: 4
```

*Важно*: изменения в написанном ранее коде класса `Box` не допускаются.

### Часть 3: класс BoxList

Унаследуйте класс `BoxList<T>` от `List<Box<T>>` так, чтобы исполнение функции `Part3` приводило к следующему выводу:
```
=== Часть 3: класс BoxList ===
[[1], [2], [3], [4], [5], [6], [7], [8]]
[[a], [b], [c], [d], [e], [f], [g], [h]]
```

*Важно*: изменения в написанном ранее коде класса `Box` и переопределение в наследнике функций класса `List` 
не допускаются. Но переопределить функцию `ToString`, объявленную в классе `object` придётся. Можно использовать, например, такую реализацию: `return $"[{string.Join(", ", this)}]";`. Подумайте, что именно происходит в этом коде.

*Подсказка*. К сожалению, мы забыли определить в классе `Box` функцию `ToString`. Поскольку модифицировать его
код нельзя, а `ToString`, унаследованная от `List`, вызывает `ToString` для своих элементов, 
придётся как-то выкручиваться. Например, в классе `BoxList<T>` можно определить вложенный класс DecoratedBox<T>,
унаследовав его от `Box<T>` и переопределив в нём `ToString` требуемым согласно заданию образом. 
Далее можно определить функцию `Add`, которая сможет добавлять в список элементы типа `T`, помещая их
в `DecoratedBox<T>` и затем используя `Add` предка. 


## Задание 5

Реализуйте сначала класс `Logger` и убедитесь, что первый тест проходит.

После чего реализуйте декоратор `LoggerDecorator` над произвольным
`ILogger` классом. Который будет добавлять к любому сообщению строчку
"Message N: ", где N - это номер сообщения, начиная с 1.

## Начисление баллов за занятие

По одному баллу за каждое задание.

